#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Optimizing Kernel Density Estimator in Python
\end_layout

\begin_layout Author
Reynaldo Gil
\end_layout

\begin_layout Abstract
The work show the results of creating and optimizing python code for computing
 a Kernel Density Estimator over object of very high dimensionality.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Kernel Density Estimation (KDE) is a non-parametric way to estimate the
 probability density function of a random variable (
\begin_inset CommandInset citation
LatexCommand cite
key "kde_wiki"
literal "false"

\end_inset

).
\end_layout

\begin_layout Section
Mathematical model
\end_layout

\begin_layout Standard
Given a collection of 
\begin_inset Formula $k$
\end_inset

 points 
\begin_inset Formula $z_{i}\in R^{d}$
\end_inset

 the log-likelihood of a point 
\begin_inset Formula $x\in R^{d}$
\end_inset

 can be expressed :
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\log p(x)=\log\sum_{i=1}^{k}p(z_{i})p(x|z_{i})
\]

\end_inset


\end_layout

\begin_layout Standard
Assuming that 
\begin_inset Formula $p(z_{i})=\frac{1}{k}$
\end_inset

 and 
\begin_inset Formula $p(x|z_{i})$
\end_inset

 is described by the product of Gaussian components for each dimension:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
p(x_{j}|z_{i})=\frac{1}{\sigma\sqrt{2\pi}}e^{\frac{(x_{j}-z_{ij})^{2}}{2\sigma^{2}}}
\]

\end_inset


\end_layout

\begin_layout Standard
Then:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\log p(x)=\log\sum_{i=1}^{k}\frac{1}{k(\sigma\sqrt{2\pi})^{d}}\prod_{j=1}^{d}e^{-\frac{(x_{j}-z_{ij})^{2}}{2\sigma^{2}}}
\]

\end_inset


\end_layout

\begin_layout Standard
Applying the exponential and logarithms rules this can be expressed as:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\log p(x)=-\log k-d\log\sigma-\frac{d}{2}\log2\pi+\log\sum_{i=1}^{k}e^{-\sum_{j=1}^{d}\frac{(x-z_{ij})^{2}}{2\sigma^{2}}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\log p(x)=-\log k-d\log\sigma-\frac{d}{2}\log2\pi+\log\sum_{i=1}^{k}e^{-\frac{\left|x-z_{i}\right|^{2}}{2\sigma^{2}}}
\]

\end_inset


\end_layout

\begin_layout Standard
This is equivalent to:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\log p(x)=\log\sum_{i=1}^{k}e^{\log\frac{1}{k}-\sum_{j=1}^{d}\left\{ \frac{(x_{j-z_{ij})^{2}}}{2\sigmaÂ²}+\frac{1}{2}\log2\pi\sigma^{2}\right\} }
\]

\end_inset


\end_layout

\begin_layout Standard
Unless both formulas are equivalent in the work is used the first one because
 the computation that depends of the vector is small and more separated
 of the computation that only depends on parameters and sizes that need
 to be computed only one time.
 So, it is a bit easier to optimize the code in this way.
\end_layout

\begin_layout Standard
One problem we found was the computation of 
\begin_inset Formula $\log\sum_{i=1}^{k}e^{-\frac{\left|x-z_{i}\right|^{2}}{2\sigma^{2}}}$
\end_inset

 because when 
\begin_inset Formula $\sigma$
\end_inset

 is small and the vector have high dimensionality the exponential return
 zero due the value be so large and the limited resolution of the fixed
 point arithmetic.
 One solution can be use other arithmetic, but they are so slow.
 The problem can be solved more efficiently using LogSumExp (
\begin_inset CommandInset citation
LatexCommand cite
key "LogSumExp"
literal "false"

\end_inset

) This function set:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\log\sum e^{x_{i}}=\max(x_{i})+\log\sum e^{x_{i}-\max(x_{i})}
\]

\end_inset


\end_layout

\begin_layout Standard
Using it, the exponents are not big and the resolution problem doesn't happens.
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Standard
The interpreted and dynamic computation of python allow an easy programming
 but the execution is very inefficient because every object use a lot of
 additional memory and need to check its type in execution time.
 This problem increase with the size of the data.
 It is needed to avoid computation in Python to achieve a better performance.
 Due to this problem a lot of libraries implemented in C or other languages
 have been created.
 This libraries do the hard work and python works as the glue between then.
 In particular numpy is the basic library for scientific computing.
 It implements vector operations that can be optimized for some architectures.
 
\end_layout

\begin_layout Standard
The first optimization was implement all the operations that where possible
 using numpy functions over arrays.
 This avoid the overload python execution and can take advantage of the
 vector operation.
\end_layout

\begin_layout Standard
The second was paralyzing the code at a higher functional level.
 This algorithm offer several levels of parallelism, in particular the terms
 of the final evaluating function can be computed independently.
 The validation or testing matrix is divided among the available processors
 using the multiprocessing library.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "kde"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
